## 概述

### 互联网的组成

1. **边缘部分** 由所有连接在互联网上的主机组成。这部分是**用户直接使用的**，用来进行通信和资源共享
2. **核心部分** 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。



边缘部分：

1. 客户-服务器方式（C/S方式）
2. 对等连接方式（P2P）

核心部分：

1. **电路交换**：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。
2. 报文交换：整个报文先传送到相邻节点，全部存储下来后查找转发表，转发到下一个节点。
3. 分组交换：传输方式同报文交换，不同的是，每次只传输报文的一部分，而不是一整个传送。

### 架构

网络协议分为五层：应用层、运输层、网络层、链路层和物理层

主机有全部五层，路由器有下三层，交换机有下两层。

信息分组的名称：

1. 应用层：**报文**
2. 运输层：TCP：**报文段**，UDP：用户数据报
3. 网络层：**分组**或**包**或**IP数据报**
4. 链路层：**帧**

### 网络性能

性能指标：

1. **速率** ，单位bit/s，1kbit/s=1000bit/s,不同于1KB=1024B,速率指的是传输数据的速度，通常指额定速率。

2. **带宽**，单位bit/s,数据能通过的最大速率。

3. **吞吐量**，单位bit/s，数据通过的实际量。

4. **时延**
   1. 发送时延（传输时延），指发送数据帧所需要的的时间
   2. 传播时延：指数据在信道中传播的时间。
      - 传播时延=信道长度（m）/电磁波在信道上的传播速率(m/s)
   3. 处理时延：主机或路由器在收到分组时需要进行一定的处理，这就需要一定时间。
   4. 排队时延：分组在传入路由器后要先在输入队列中排队等待处理，排队的时间就是排队时延。
   5. 总时延=发送时延+传播时延+处理时延+排队时延
   
5. 时延带宽积：传播时延*带宽

6. 往返时间RTT。

7. 利用率：

   - D~0~表示网络空闲的时延，D表示网络当前的时延，U表示网络的利用率，公式：![image-20211226140646410](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211226140646410.png)

     当网络利用率达到其容量的1/2时，时延就要加倍，当网络利用率接近1时，时延就会接近无穷大。

   - **丢包**

     当利用率较大，就有可能产生丢包，路由器中的队列溢出，就会抛弃后来的分组。

## 应用层

### DNS （Domain Name System）

DNS：域名系统，通常是由其他应用层协议所使用，将用户提供的主机名解析为IP地址。使用的是UDP协议。

工作流程：

1. 同一台用户主机上运行着DNS应用的客户端。
2. 浏览器从上述URL中抽取主机名，并将主机名传给DNS应用的客户端。
3. DNS客户端向DNS服务器发送一个包含主机名的请求。
4. DNS客户端最终会受到一份回答报文，含有对应于该主机名的IP地址。
5. 浏览器与该IP地址的HTTP服务器进程发起TCP连接

#### 工作机理

p87

##### 分布式、层次数据库

DNS服务器分为不能层级，分别是根NDS服务器、顶级域（Top-Level Domain，TLD）NDS服务器和权威DNS服务器

![image-20211226144238019](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211226144238019.png)

还有一类重要的DNS服务器，称为**本地DNS服务器**(local DNS server)。严格说来，一个本地DNS服务器并不属于该服务器的层次结构，但它对 DNS层次结构是至关重要的。每个ISP(如一个居民区的ISP或一个机构的ISP）都有一台本地DNS服务器（也叫默认名字服务器)。

有使用DNS查询IP有两种方式：**递归查询**和**迭代查询**。

<img src="https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211226145439599.png" alt="image-20211226145439599" style="zoom:67%;" /><img src="https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211226145856543.png" alt="image-20211226145856543" style="zoom:67%;" />

通常采用第一个图片的方法：从请求主机到本地DNS服务器的查询时递归的，其余查询时迭代的。

##### DNS缓存

某DNS服务器接收到一个DNS回答时，它能将映射缓存在本地存储器上。该映射可以是TLD服务器、权威DNS服务器和主机的IP地址。例如：

假定主机 apricot. nyu. edu向dns. nyu. edu查询主机名cnn.com的IP地址。此后，假定过了几个小时，纽约大学的另外一台主机如kiwi. nyu. edu也向dns. nyu. edu查询相同的主机名。因为有了缓存，该本地DNS服务器可以立即返回cnn.com的P地址，而不必查询任何其他DNS服务器。本地DNS服务器也能够缓存TLD服务器的IP地址，因而允许本地DNS绕过查询链中的根 DNS服务器。事实上，因为缓存，除了少数 DNS查询以外,根服务器被绕过了。

##### DNS记录和报文

### HTTP

p64

Web的应用层协议是**超文本传输协议**（HyperText Transfer Protocol，HTTP），它是Web的核心。使用TCP作为传输层协议。

HTTP是一个**无状态协议**，服务器不会存储任何关于客户的状态信息。假如某个特定的客户在短短的几秒内两次请求同一个对象，服务器并不会因为刚刚为该客户提供了该对象就不再做出反应，而是重新发送该对象。就像完全忘了之前做过的事一样。

连接方式：

1. **非持续连接**：每个请求/响应对是经一个单独的TCP连接发送的。HTTP1.0使用非持续连接
2. **持续连接**：所有的请求及其响应经相同的TCP连接发送。一般连接长时间未被使用，服务器就会断开连接。HTTP1.1默认使用持续连接。

持续连接工作方式：

1. **非流水线**：即受到上一个请求的响应后才能发送下一个请求。
2. **流水线**：请求一个接一个的连续发送，节省空闲时间。

## 传输层

### UDP和TCP概述

UDP的特点：

1. UDP是**无连接**的。
2. UDP使用**尽最大努力交付**，即**不保证可靠交付**，因此主机不需要维持复杂的连接状态表。
3. UDP是**面向报文**的。即它只在上层送下来的报文加上首部就直接往下层送，不做任何其它处理。
4. UDP**没有拥塞控制**。
5. UDP**支持一对一、一对多、多对一和多对多的交互通信**。
6. UDP的**首部开销小**。

TCP的特点：

1. TCP是**面向连接**的运输层协议。
2. 每一条TCP连接只能有两个**端点**，即只支持**一对一**交互通信。
3. TCP提供**可靠交互**通信。
4. TCP提供**全双工通信**。即两边可以同时并在任何时候发送数据，不会冲突。
5. **面向字节流**。

相同点：

1. 都是运输层的协议
2. 都能进行**多路复用**和**解复用**
3. 都**不提供延时保证**和**带宽保证**

不同点：

|            | TCP                        | UDP                        |
| :--------- | -------------------------- | -------------------------- |
| 1          | 可靠传输                   | 不可靠传输                 |
| 2          | 基于连接                   | 面向非连接                 |
| 3          | 提供流量控制               | 不提供流量控制             |
| 4          | 提供拥塞控制               | 不提供拥塞控制             |
| 5.结构不同 | 协议结构复杂，包含很多信息 | UDP包含长度和校验和信息。  |
| 6.         | 负载大，开销大             | 负载小，开销小             |
| 7          | 仅支持一对一               | 支持一对一，一对多，多对多 |
| 8.         | 面向字节流                 | 面向报文                   |
| 9.实时性   | 实时性低                   | 实时性高                   |



部分应用层的应用使用的运输层协议：

![image-20211227170230003](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227170230003.png)

### 可靠数据传输原理

p135

#### 经完全可靠信道的可靠数据传输：rdt1.0

假设底层信道是完全可靠的，不会产生错误。

![image-20211227181928991](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227181928991.png)



发送方：接受上层传来的数据，产生包含该数据的分组，发送到下层。

接收方：从下层接受到一个分组，从分组中取出数据，将数据传给上层。

#### 经具有比特差错信道的可靠数据传输：rdt2.0

假设在信道中，比特可能受损。

要用到自动重传请求协议：

- 差错检测。
- 接收方反馈。接收方检测到分组没有错误则返回ACK，有错误则返回NAK。
- 重传。发送方收到反馈后判断是否要重传该分组。

FSM：

![image-20211227183131382](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227183131382.png)

- 发送方：接受上层数据，打包并发送，然后等待ACK或NAK，；若接收到NCK，则重发，接收到ACK则回到等待上层调用状态或发送下一组分组。
- 接收方：等待下层传来的分组，接受分组后，进行差错检测，如果检测到错误，返回NAK，若正确，将分组中的数据送给上层，返回给发送方ACK。

发送方必须等待收到ACK才能发送下一组分组，所以rdt2.0被称为**停等协议**。

#### rdt2.1和2.2

**rdt2.1**

ACK和NAK也有可能受损，假设发送方收到受损的数据统一采取重发的策略，接收方就有可能接受到两次重复的分组，在rdt2.0，接受方无法检测出是否分组是否重复，这时引入rdt2.1。

rdt2.1为分组引入了01序号。

![image-20211227190500015](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227190500015.png)

![image-20211227190615065](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227190615065.png)

当发送方发送了分组1，如果收到了ACK则继续发送分组0，如果收到了NAK1，则重发分组1；

当接收方此时等待分组1，实际上它收到了分组0，则返回NAK1；若收到了分组1，且分组没有错误，则返回ACK,将数据送给上层应用，若是分组1有错误，返回NAK1，转变状态为需要接受分组0。

**rdt2.2**

rdt2.2作用同rdt2.1，不过**取消了NAK**

![image-20211227191802609](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227191802609.png)

当发送方发送了分组1，若收到ACK1，说明接收方成功接受了分组1，发送方可以发送分组0了；若收到ACK0，说明接收方收到的分组有错误，重发分组1；

当接受方等待分组1，却收到了分组0，则发送ACK0,；若收到了分组1且没错误，则发送ACK1，等待分组0，若分组错误，则发送ACK0；

#### rdt3.0，经具有比特差错的丢包信道的可靠数据传输

在发送方加入**倒计数定时器**，在一个给定的时间量过期后，可中断发送方。

![image-20211227193008645](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227193008645.png)

每次发送分组后启用定时器，如果时间内无法接受到ACK或NAK，则认为分组丢失，选择重传分组。

以下是rdt3.0运行时的各种情况：

![image-20211227193556502](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227193556502.png)

#### 流水线可靠数据传输协议

rdt3.0作为停等协议，效率好差，改良后就是**流水线可靠数据传输协议**（不是具体协议，只是某几个协议的统称）。

![image-20211227194335901](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227194335901.png)

带来的影响：

- 必须增加序号范围，因为每个传输中的分组不能重复。
- 发送方和接收方两端必须缓存多个分组。发送方起码能缓存未确认的分组，接受方要缓存已正确接受的分组
- 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是:**回退N步**（Go- Back-N,**GBN**) 和**选择重传**( Selective Repeat,**SR**)。

#### 回退N步（Go- Back-N,GBN) ，滑动窗口协议

![image-20211227195726149](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227195726149.png)

在发送方，有一段序列范围，如上图。发送方必须按序发送分组，同时接收方也必须按序接收分组。

发送方必须响应的三种类型事件：

1. 上层的调用。当上层调用时，发送方会检查发送窗口是否有N个发送但未确认的分组，若有，则说明发送窗口满了。如果窗口未满，则产生分组并发送，如果满了，则告诉上层窗口满了，等会儿再试试。
2. 收到一个ACK。GBN采用**累积确认**，如果收到ACKn，则说明分组n以及n之前的分组都被接受方确认了。窗口的左端移到n+1。
3. 超时事件。整个GBN中只有**一个定时器**，它可被当做是最早的已发送但还未被确认的分组所使用的定时器。当收到ACK后，如果还有分组未被确认，则重启定时器。

![image-20211227201101717](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227201101717.png)

接受方只**按序接受**，乱序的分组全部丢弃。发送方只有在超时时才会重发分组，重发窗口中的所有分组。



#### **选择重传**( Selective Repeat,**SR**)

不用按序发送和接受，发送方和接受方都有一条序列和窗口。

![image-20211227203648480](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227203648480.png)

因为每个分组都是独立的，每块分组都需要一个定时器。



发送方和接收方的行为：

- 发送方
  1. 从上层收到数据。当从上层接收到数据后，SR发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送;否则就像在CBN中一样，要么将数据缓存，要么将其返回给上层以便以后传输。
  2. 超时。定时器再次被用来防止丢失分组。然而，现在每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组。
  3. 收到ACK。如果收到ACK，倘若该分组序号在窗口内，则SR发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。
- 接收方
  1. 序号在〔 rcv_base，rcv_base +N-1]内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，一个选择ACK被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号(图3-23中的 rcv_base)，则该分组以及以前缓存的序号连续的（起始于rcv_base的）分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。举例子来说，考虑一下图3-26。当收到一个序号为rcv_base =2的分组时，该分组及分组3、4、5可被交付给上层。
  2. 序号在〔 rcv_base -N，rcv_base -1]内的分组被正确收到。在此情况下，必须产生一个ACK，即使该分组是接收方以前已确认过的分组。
  3. 其他情况。忽略该分组。

SR操作

![image-20211227204328262](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227204328262.png)

### TCP

![image-20211228181144860](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228181144860.png)

TCP中首部有个**确认号**，该字段存放的信息为期望收到对方下一个报文段的第一个数据字节的序号，再下面图片中常以ack表示。ACK字段不同于ack，ACK字段置为1时，确认号字段才有效。

#### TCP可靠数据传输

TCP采用的是GBN和SR的混合方法。

采用**累积确认**，接收方也会存储乱序的分组，收到乱序分组时，都会发送最前面需要接收的分组的ack；

在TCP中，两方都可以发送和接收，所以，每一方都有两组缓存。

TCP使用**超时重传**

![image-20211228144024118](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228144024118.png)

![image-20211228144229651](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228144229651.png)

**快速重传**：当收到确认号重复3次（即3个冗余ACK），则不等待超时，直接重发seq100的分组。

#### RTT的指数加权移动平均计算公式

指数加权移动平均计算公式：

![image-20211227210218543](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211227210218543.png)

SampleRTT是某时刻测量的RTT值，EstimatedRTT是SampleRTT均值。



#### 拥塞控制

在发送方设置一个拥塞窗口，窗口大小为cwnd，发送并未确认的分组不能超过cwnd。

拥塞控制分为三个状态：**慢启动**、**拥塞避免**和**快速恢复**。

1. 慢启动

   cwnd通常设置为一个MSS（最大报文段长度）的较小值，初始速率则为MSS/RTT.

   每首次收到一个报文段的确认号，就会cwnd增加一个MSS。

   ![image-20211228160721097](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228160721097.png)

   例如上图：第一次发送一个报文段，收到ACK后，增加1个MSS，就可以发送2个报文段，再次收到这2个报文段的ACK后，就可以发出4个报文段。所以慢启动时，cwnd呈**指数增长**。

   **何时停止**：

   1. 当出现超时时，说明网络出现拥塞，就将cwnd重新设为1个MSS。当发现拥塞时，会将另一个属性ssthresh（**慢启动阈值**）设置为cwnd/2。
   2. 当cwnd超过ssthresh后，会结束慢启动状态，进入**拥塞避免**状态。
   3. 当接受到3个冗余ACK后，会结束慢启动，进行**快速重传**，进入**快速恢复**状态
   4. FSM图![image-20211228161946051](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228161946051.png)

2. **拥塞避免**

   一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时的一半，说明离拥塞不远了，这是cwnd不能再采用翻倍的策略。

   拥塞避免状态里，每个RTT只将cwnd增加一个MSS，即每个报文ACK只增加MSS/cwnd。不再是指数增长，而是**线性增长**。
   
   当遇到超时时，与慢启动一样，将cwnd设置为1个MSS，ssthresh设置为cwnd的一半，进入**慢启动**。
   
   当遇到3个冗余ACK时，将cwnd和ssthresh都设置为cwnd/2，进入**快速恢复**状态。
   
3. 快速恢复（不是重点）

   在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS。最终，当对丢失报文段的一个ACK到达时，TCP在降低cwnd 后进人拥塞避免状态。

4. ![image-20211228164839754](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228164839754.png)



#### TCP连接（三次握手）

三次握手的示意图：

![image-20211228165555144](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228165555144.png)

步骤：

1. 客户端的TCP首先向服务端的TCP发送一个特殊的TCP报文段。该报文段**不包含应用层数据**。报文段首部有一个标志位（**SYN**比特）被置为1，该报文段称为SYN报文段。客户机会随机选择一个**初始序号**（client_isn)，并放置于SYN报文段中。
2. 服务器收到了SYN报文段的IP数据报，服务器会提取出SYN报文段，为该**TCP连接分配TCP缓存和变量**，并向客户TCP发送允许连接的报文段。该报文段也**不含应用层数据**。包含的3个重要信息：SYN置为1；ACK字段置为client_isn+1；服务器选择的初始序号（server_isn)，并放置到TCP报文段首部的序号字段。该允许连接的报文段被称为**SYNACK报文段**。
3. 在收到SYNACK报文段后，客户机也要给**连接分配缓存和变量**。发送另一个报文段，这最后一个报文段是对服务器的SYNACK报文段进行确认。因为连接已经建立了，所以该SYN比特**置为0**。且第三个报文段可以携带客户机的应用层数据了。

TCP连接的关闭（**不是重点**）：

![image-20211228175421847](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228175421847.png)

步骤：

1. 客户机先向其TCP发出连接释放报文段，并停止再发送数据。该报文段将终止控制位FIN置1，seq=u，它等于前面已传送的数据的最后一个字节的序号加1.这时A进入FIN-WAIT-1（终止等待1）
2. B收到了连接释放报文段，立即发出确认，ack=u+1。TCP服务器进程通知高层应用进程，此时，从A到B这个方向的连接就释放了，这时的TCP连接处于**半关闭**状态，即A已经没有数据发送了，但若B要发数据，A仍要接收。
3. A收到来自B的ACK后，就进入FIN-WAIT-2，等待B发出的连接释放报文段。
4. 若B没有数据要发送给A了，其应用进程就会通知TCP释放连接。这时B发出连接释放报文，同样FIN=1，B进入LAST-ACK状态，等待A的确认。
5. A在收到B的连接释放报文段后，发出确认号。进入TIME-WAIT，即等待一定时间后完全关闭。等待这段时间是主要为了避免发出的确认报文段丢失或者出错。在再一次接受到B的FIN报文段后，说明确认报文段丢失，再次发送。B在收到确认报文段后直接关闭TCP连接。

## 网络层

一般的IPv4首部有20字节

![image-20211228184227661](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228184227661.png)

### IPv4数据报分片

IPv4首部里，**标识**、**标志**和**片偏移**字段用于**分片**。

不同的链路层协议有着不同的数据帧承载量，一个链路层帧能承载的最大数据量叫做**最大传输单元**（Maximum Transmission Unit，**MTU**），所以在IP层需要对数据报进行**分片**。分片可以再路由器上进行，但**重组**只能在**端系统**（主机）中进行。

- **标识**：发送主机通常将它发送的每个数据报的标识号加1。所以**标识用来向接收方说明，哪些数据报分片是由同一个数据报分出来的**。
- **标志**：**用来确定该分片是不是数据报的最后一片**，标志为1说明该分片不是最后一片，标志位0说明是最后一片。
- **偏移量**：表示的是该分片在数据报中的位置，以**字节**来表示，比如说偏移量1000，说明该分片在数据报第1000字节处开始。**偏移量用来判断分片的顺序**。

![image-20211228184131787](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228184131787.png)

ID是标识，fragflag是标志，offset是偏移量

### IPv4编址

p217

#### 无类地址

##### **子网**的概念：

![image-20211228193013732](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228193013732.png)

图中有6个子网，分别是223.1.1.0/24, 223.1.2.0/24, 223.1.2.0/24, 223.1.7.0/24, 223.1.8.0/24, 223.1.9.0/24.

通过路由器隔离的网络中的每一个都加作一个子网。

其中的/24叫做**子网掩码**。

这种有子网掩码的网络地址分配策略被称为**无类别域间路由选择**（CIDR）。

形式为a.b.c.d/x的地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的**前缀**（可能也叫**网络号**，**不确定网络号和前缀是否是一个东西**）。一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。可以理解为，该组织是一个较大的子网。该组织内部的设备有着相同的网络前缀。组织外的路由器只需关注IP地址的前x位，就能确定该数据报的目的地是否属于该组织内。

##### **地址聚合**:

使用单个网络前缀通告多个网络的能力通常称为**地址聚合**，也称**路由聚合**。

假设某个ISP向外界通告，所有地址的前20比特与200.23.16.0/20相符的数据报全往它这发。那么外面无需知道ISP下的子网结构，可以直接将符合条件的数据报发往这个ISP的路由器。

如下图：

这张图里，Fly-By-Night-ISP通告了200.23.16.0/20的地址，实际上他内部还有8个子网，但其它机构不知道，所以会将所有符合的网络数据报发给它，再有它来路由给下属的子网。

![image-20211228195814764](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228195814764.png)

##### 最长前缀匹配

真实网络中，子网的关系不一定是完全如上图的层次关系。

例如Fly-By-Night-ISP让组织1通过它的辅助的ISPs-R-Us与因特网相连，就会出现如下图：

![image-20211228200717964](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228200717964.png)



ISPs-R-Us会同时转发符合原来的199.31.0.0/16的数据报，同时也能转发符合200.23.18.0/23的数据报。这时，如果外界因特网要传送目的IP为200.23.18.1的数据报时，会发现两个ISP都能接收，这时就会使用**最长前缀匹配原则**，同时匹配的情况下，选择转发向前缀长的网络。所以会将数据报发向ISPs-R-Us。

#### 分类编址（ABCDE类编址）

在CIDR被采用之前，IP地址的网络部分被限制为8、16或24，分别称为A、B和C类地址。

![image-20211228202135077](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228202135077.png)

1. A类地址

   一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到126.0.0.0。可用的A类网络有126个，每个网络能容纳1亿多个主机.

2. B类地址

   一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。

3. C类地址

   一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。

![分类地址](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/3c79eaeb94b94e9e865d893e1855e059.jpeg)

### 分组的转发（路由表）

1. 从收到的数据报的首部提取目的IP地址D。
2. 先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和D逐位想“与”，看结果是否和相应的网络地址匹配。若匹配，把分组进行直接交付，转发任务完成。否则就是间接交付，执行（3）。
3. 若路由表中有目的地址为D的特定主机路由，则吧数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）。
4. 对路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和D逐位相“与”，其结果与该行的网络地址匹配，则把数据报传送给该行指明的下一跳路由；否则，（5）
5. 若路由表有个默认路由，则发给默认路由，否则报告转发分组出错。

路由表示例：

![image-20211228205744219](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228205744219.png)

### 网络地址转换（NAT）

NAT可以将**专用网络**的多个IP地址映射到一个同一个IP上，常用于家庭网络中或具有专用地址的地域。家庭网络中的主机可以使用10.0.0.0/24编址的彼此发送信息，但向外却不能直接发送信息，要经过NAT转换表.

![image-20211228214300607](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211228214300607.png)

可以将图中的路由器看做是一个家庭路由器，路由器从ISP的DHCP服务器得到它的IP地址，然后路由器自己运行一个DHCP服务器，可以为该路由器控制的家庭网络中的计算机提供IP地址。

所有从该子网中出来的数据报的IP都会经NAT转换表，转变成138.76.29.7。

路由器中的每一个端口都映射到子网中的某个主机上的某个进程。比如说10.0.0.1的主机上的端口为3345的进程发出的数据报，都会在NAT转换表中IP138.76.29.7端口5001。外界网络无法知道子网内部的具体情况。

NAT的一些问题，专有网络的IP地址，外界是无法使用的，所以专有网络的主机想作为服务器时就会出现问题，外界无法使用主机的IP地址主动进行连接，解决方案包括**NAT穿越**。

**NAT的优点：**
节省合法的公有ip地址
地址重叠时，提供 解决办法
网络发生变化时，避免重新编址
NAT对我们来说最大的贡献就是帮助我们节省了大量的ip资源
**NAT的缺点：**
无法进行端到端的ip跟踪（破坏了端对端通信的平等性）
很多应用层协议无法识别（比如ftp协议 ）

### 链路状态路由算法（LS）（不重要）

使用Dijkstra算法实现的。

### 距离向量路由选择算法

**距离向量**（Distance-Vector，**DV**）算法是一种迭代的、异步的和分布式的算法，而LS算法是一种使用全局信息的算法。

分布式：每个结点都要直接相连的邻居接收某些信息，执行计算，然后将其计算结果分发给邻居。

迭代：此过程一直要持续到邻居之间无更多信息要交换为止。

异步：他不要求所有节点相互之间步伐一致地操作。

DV所使用的算法方程Bellman-Ford方程：

​							d~x~(y)=min~v~{c(x,v)+d~v~(y)}

x是当前节点，y是目标节点，d~x~(y)是x到y的最小开销路径的开销，v是所有的邻居节点。



使用DV算法时，每个节点x维护下列路由选择信息：

- 对于每个邻居v，从x到直接相连邻居v的开销为c(x,v)。
- 节点x的距离向量，即D~x~=[D~x~(y):y∈N]，包含了x到N中所有目的地y的开销估计值。
- 它的每个邻居的距离向量，即对x的每个邻居v，有D~v~=[D~v~(y):y∈N]。

每个节点不时的向它的每个邻居发送它的距离向量副本。当节点x收到它的任何一个邻居v的新距离向量，它保存v的距离向量，并使用Bellman-Ford方程更新它自己的距离向量。

​						D~x~(y)=min~v~{c(x,v)+D~v~(y)}

如果节点x的距离向量因这个步骤而改变，那么节点x会发送更新后的距离向量给所有邻居，让邻居更新它们自己的距离向量。只要所有的节点持续的以异步的方式交换他们的距离向量，最终D~x~(y)最后会收敛到d~x~(y)，即实际的最小开销路径的开销。

### 内部网关协议RIP

RIP是一种分布式的**基于距离向量的路由选择协议**。

RIP协议的“距离”也称“**跳数**”，每经过一个路由器，跳数就加1。RIP认为好的路由就是它通过的路由器的数目少，即“距离短”。RIP允许一条路径最多只能包含15个路由器。因此“距离”等于16时即相当于不可达。可见RIP只适用于小型互联网。

RIP协议的特点是：

1. 仅和相邻路由器交换信息。
2. 路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表。
3. 按固定的时间间隔交换路由信息。

示例：![image-20211229153807555](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211229153807555.png)

![image-20211229154218224](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211229154218224.png)

## 链路层

### 循环冗余校验

**循环冗余检测（CRC）编码**用于差错检测。CRC编码也被称为**多项式编码**。

发送方和接受方必须协商一个r+1的比特模式，称为**生成多项式**，表示为G。

D表示发送的数据段，假设比特长度为d，

通过D和G生成CRC比特，表示为R，长度为r。

最后生成的数据长度为d+r，实际的值为D·2^r^ XOR R

如下图。

![image-20211229161508246](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211229161508246.png)

CRC计算采用**模2算术**，在加法和减法中不做进位和借位，即异或运算，乘除法与正常算术相同。

该比特模式的值除以G是余数为0的，如果有余数，说明出现错误，即：
​			D·2^r^ XOR R=nG

两边都用R异或，可得

​			D·2^r^=nG XOR R

这个等式说明，用G来除D·2^r^,余数刚好是R，所以R可以用一下公式计算

​			R=remainder(D·2^r^/G)

例题：

**要发送的数据为101110，采用CRC的生成多项式P(X)=X^3^+1，试求应添加在数据后面的余数，请写出计算过程。**

 

由于P(X)=X^3^+1，则除数G=1001，r=3采用CRC的计算过程如下：

![image-20211229163544370](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211229163544370.png)

则发送方发送的全部比特为101110011

### 信道划分协议

信道划分分为**时分多路复用**（TDM）、频分多路复用（FDM）和码分多址（CDMA）

**TDM**：

将时间划分为**时间帧**，然后将1个帧划分为N个时隙，将时隙分给N个节点，节点只有在自己时隙内才能发送数据。

**FDM**：

将信道划分为不同的频段，并把每个频率分配给N个节点中的一个。

![image-20211229191148893](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211229191148893.png)

信道划分的缺点：若信道有R bps的带宽每个节点的速率最多只能有R/N bps，即使其它节点没有使用信道。



### 载波侦听多路访问（CSMA）

节点在传输帧之前，会侦听链路中是否有其它节点已经在传输了，那么节点会等待链路空闲后再传输帧。

但是，数据传输是要时间的，可能节点B发送了一个帧，但还没传播到D，节点D侦听不到，以为信道是空闲的，便发送了自己的帧，然后发生了碰撞，导致两个数据都受损，但节点B和D都不知道发生了碰撞，就会一直把帧传输完。

如下图：

![image-20211229165914948](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211229165914948.png)

### 具有碰撞检测的载波侦听多路访问（CSMA/CD）

CSMA/CD相较于CSMA，多了碰撞检测功能，当某节点执行碰撞检测时，一旦它检测到碰撞将立即停止传输。

![image-20211229184509020](https://gitee.com/hu-chaoran/typora-upload-images/raw/master//images/image-20211229184509020.png)

CSMA/CD协议的**要点**：

- **多点接入**：就是说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。
- **载波监听**：载波监听就是检测信道。**不管在发送前，还是发送中，每个站都必须不停地检测信道**。发送前，是为了获得发送权。如果检测出已经有其他节点在发送数据，就等到信道变为空闲时才能发送。在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞，即**碰撞检测**
- **碰撞检测**，即总线上的信号变多，电压就会变大，当适配器检测到的信号电压变化幅度超过一定时，就认为总线上有两个站同时在发送数据，表明产生了碰撞。若产生碰撞，其适配器就要立即停止发送，然后等待一段**随机时间**后再次发送

CSMA/CD不同于信道划分协议，它在只有一个节点的情况下，节点可以由满额的速率。虽然多个信道可能会传输冲突，但也能即使停止冲突，在信道中正在运行的节点不多时优于信道划分协议。
